synchronized的底层实现（虚拟机规范并没有要求怎么样实现，不同的虚拟机可以有不同的实现方式，
下面讲的都是Hotspot的实现方式）：
1.在jdk1.6(记不太清)之前，synchronized的底层实现是重量级的，每次都需要向操作系统去申请，效率很低。
2.后来改进为有锁升级的概念：
  2.1.当第一个线程去访问某把锁上午时候，会在锁定的对象头markword上记录该线程的ID，实际上到现在还没有加锁，
     默认只有一个线程访问该锁。此时就是偏向锁，就是偏向第一个进来访问的线程。
  2.2.如果偏向锁有线程竞争的话，就升级为自旋锁，等待的线程自旋最多十次，期望拿到锁，拿到锁就执行。
  2.2如果自旋锁自旋十次后还没拿到锁，就升级为重量级锁，需要去向操作系统申请资源。这是一个锁升级的过程。

  备注：当自旋锁没有拿到锁后，会进入cpu的就绪队列，就不占用CPU资源了，自旋的时候会占用CPU资源。
  当线程数少，加锁代码执行时间短的时候，用自旋锁更适合。
  当线程数多，而且加锁代码执行时间长的时候，用系统锁更适合。

  一句话总结：synchronized锁定对象，并通过CAS的方式更改对象头上的锁标志，并且把当前线程的ID也通过CAS的方式写到对象的
    mark word上，此时该对象就成为被锁定代码的监视器。

    锁优化的方式：1.锁粒度细化，尽量减少锁定的不必要的代码块；
                 2.锁粒度粗化，当一段代码中写的细粒度锁太多，锁征用太频繁的时候，不如就用一把锁整个锁住。
